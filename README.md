> 注解

    @Target：用于描述注解的使用范围，即：被描述的注解可以在什么地方使用
    
    @Retention：表示需要什么保存该注释信息，用于描述注解的生命周期
    
    级别范围：Source < Class < Runtime
    
    @Document：说明该注解被包含在java doc中
    
    @Inherited：说明子类可以集成父类中的注解
    
> 反射

    在运行时判断任意一个对象所属类
    
    在运行时构造任意一个类的对象
    
    在运行时判断任意一个类所具有的成员变量和方法
    
    在运行时获取泛型信息
    
    在运行时调用任意一个对象的成员变量和方法
    
    在运行时候处理注解
    
    生成动态代理
    
    Class :
        一个类在内存中只有一个Class对象，通过getClass(className) 获取的都是同一个对象
        一个类被加载后，类的整体结构都会被封装在Class对象中
        
    java内存：
        堆
        
            存放new的对象和数组
            
            可以被所有的线程共享，不会存放别的对象引用
        
        栈
        
            存放基本变量（会包含这个基本类型的具体数值）
            
            引用对象的变量（会存放这个引用在对堆里面的具体地址）
        
        方法区
        
            可以被所有线程共享
            
            包含了所有的class和static变量
            
    > 类的加载与ClassLoader
       类加载：将class文件字节码内容加载到内存，并将这些静态数据转换成方法区的运行时数据，生成类的 java.lang.Class 对象。
       类链接：将Java类的二进制代码合并到JVM的运行状态之中的过程
         验证：加载的类信息符合JVM规范
         准备：为类变量分配内存，并初始化类变量为默认值，在方法区中分配
         解析：虚拟机常量池的符号引用(常量名)替换为直接引用(地址)的过程
       类初始化：JVM对类进行初始化，执行类构造器方法的过程，由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的，
                虚拟机会保证一个类的方法在多相差环境中被正确的加锁和同步
                
        类加载器
            Bootstrap   /lib下的jar，JVM自带类加载器，java平台核心库，装载核心类库，该加载器无法直接获取
            Extension   jre/lib/ext目录下的包 / -D java.ext.dirs 指定目录下的jar包装入 
            System  java -classpath / -D java.class.path 所指目录下的类和jar包的装入
            自定义
        
        双亲委派机制
            当前的系统加载器，不会马上的创建该类，而是将该类委派给 扩展类加载器，扩展类加载器在委派为根加载器，
            然后引导类加载器去看这个类在不在能访问的路径下，发现 sring包已经存在了，所以就无法进行，也就是我们无法使用自己自定义的string类，而是使用初始化的stirng类
            保证了使用不同的类加载器最终得到的都是同样一个Object 对象
    
> 算法和数据结构

> IO操作

    HTTP : 客户端单向请求服务器
    WebSocket ：服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息 

> 多线程

> java8

> JVM 

    类加载器 
        实现自定义类加载器

